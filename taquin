
import tkinter as tk
import random
import heapq

# ----------------- IA de Résolution (A*) -----------------

goal_state = [[1, 2, 3, 4],
              [5, 6, 7, 8],
              [9, 10, 11, 12],
              [13, 14, 15, 0]]

def manhattan_distance(state):
    distance = 0
    for i in range(4):
        for j in range(4):
            value = state[i][j]
            if value == 0:
                continue
            goal_x = (value - 1) // 4
            goal_y = (value - 1) % 4
            distance += abs(i - goal_x) + abs(j - goal_y)
    return distance

def get_neighbors(state):
    neighbors = []
    x, y = [(ix, iy) for ix, row in enumerate(state)
                    for iy, val in enumerate(row) if val == 0][0]
    moves = [(-1,0), (1,0), (0,-1), (0,1)]
    for dx, dy in moves:
        nx, ny = x+dx, y+dy
        if 0 <= nx < 4 and 0 <= ny < 4:
            new_state = [row[:] for row in state]
            new_state[x][y], new_state[nx][ny] = new_state[nx][ny], new_state[x][y]
            neighbors.append((new_state, (nx, ny)))
    return neighbors

def serialize(state):
    return tuple(tuple(row) for row in state)

def solve_taquin(start_state):
    frontier = []
    heapq.heappush(frontier, (manhattan_distance(start_state), 0, start_state, []))
    visited = set()

    while frontier:
        est_total_cost, cost, current, path = heapq.heappop(frontier)
        if current == goal_state:
            return path

        visited.add(serialize(current))

        for neighbor, _ in get_neighbors(current):
            if serialize(neighbor) not in visited:
                heapq.heappush(frontier, (
                    cost + 1 + manhattan_distance(neighbor),
                    cost + 1,
                    neighbor,
                    path + [neighbor]
                ))

    return None

def play_solution(path, index=0):
    if index < len(path):
        global l
        l = path[index]
        update_graphical_board()
        window.after(200, play_solution, path, index + 1)

def auto_solve():
    solution_path = solve_taquin(l)
    if solution_path:
        play_solution(solution_path)
    else:
        print("Aucune solution trouvée.")

# ----------------- Interface Graphique Tkinter -----------------

def swap(i, j, x, y):
    l[i][j], l[x][y] = l[x][y], l[i][j]

def update_graphical_board():
    for i in range(4):
        for j in range(4):
            if l[i][j] == 0:
                boutons[i][j].config(text="", state="disabled", bg="gray")
            else:
                boutons[i][j].config(text=str(l[i][j]), state="normal", bg="SystemButtonFace")

def click(i, j):
    global l
    x, y = [(ix, iy) for ix, row in enumerate(l)
                    for iy, val in enumerate(row) if val == 0][0]
    if abs(i - x) + abs(j - y) == 1:
        swap(i, j, x, y)
        update_graphical_board()

def melanger():
    global l
    flat = list(range(16))
    random.shuffle(flat)
    l = [flat[i:i + 4] for i in range(0, 16, 4)]
    update_graphical_board()

# Création de la fenêtre principale
window = tk.Tk()
window.title("Jeu du Taquin 4x4 avec IA")

# Initialisation de la grille
l = [[1, 2, 3, 4],
     [5, 6, 7, 8],
     [9, 10, 11, 12],
     [13, 14, 15, 0]]

boutons = [[None for _ in range(4)] for _ in range(4)]

# Placement des boutons
for i in range(4):
    for j in range(4):
        bouton = tk.Button(window, width=5, height=2,
                           command=lambda i=i, j=j: click(i, j))
        bouton.grid(row=i, column=j, padx=2, pady=2)
        boutons[i][j] = bouton

# Boutons de mélange et résolution
shuffle_button = tk.Button(window, text="Mélanger", command=melanger)
shuffle_button.grid(row=4, column=0, columnspan=2, sticky="ew")

solve_button = tk.Button(window, text="Résoudre automatiquement", command=auto_solve)
solve_button.grid(row=4, column=2, columnspan=2, sticky="ew")

# Affichage initial
update_graphical_board()
window.mainloop()

